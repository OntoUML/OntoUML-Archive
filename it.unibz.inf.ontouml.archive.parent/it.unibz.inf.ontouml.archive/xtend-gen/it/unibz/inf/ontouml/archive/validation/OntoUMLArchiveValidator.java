/**
 * generated by Xtext 2.12.0
 */
package it.unibz.inf.ontouml.archive.validation;

import com.google.common.base.Objects;
import com.google.inject.Inject;
import it.unibz.inf.ontouml.archive.OntoUMLArchiveUtils;
import it.unibz.inf.ontouml.archive.ontoUMLArchive.BinaryAssociation;
import it.unibz.inf.ontouml.archive.ontoUMLArchive.Generalization;
import it.unibz.inf.ontouml.archive.ontoUMLArchive.ModelElement;
import it.unibz.inf.ontouml.archive.ontoUMLArchive.OntoUMLArchivePackage;
import it.unibz.inf.ontouml.archive.validation.AbstractOntoUMLArchiveValidator;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class OntoUMLArchiveValidator extends AbstractOntoUMLArchiveValidator {
  @Inject
  @Extension
  private OntoUMLArchiveUtils _ontoUMLArchiveUtils;
  
  public final static String DUPLICATED_NAME = "it.unibz.inf.ontouml.archive.validation.DUPLICATED_NAME";
  
  public final static String REFLEXIVE_GENERALIZATION = "it.unibz.inf.ontouml.archive.validation.REFLEXIVE_GENERALIZATION";
  
  public final static String UNEXPECTED_STEREOTYPE = "it.unibz.inf.ontouml.archive.validation.UNEXPECTED_STEREOTYPE";
  
  public final static String DUPLICATED_GENERALIZATION = "it.unibz.inf.ontouml.archive.validation.DUPLICATED_GENERALIZATION";
  
  @Check(CheckType.NORMAL)
  public void checkNameDuplicatedName(final ModelElement e) {
    if (((!e.getName().isEmpty()) && IterableExtensions.<ModelElement>exists(this._ontoUMLArchiveUtils.getModelElements(this._ontoUMLArchiveUtils.getContainerModel(e)), ((Function1<ModelElement, Boolean>) (ModelElement it) -> {
      return Boolean.valueOf(((!Objects.equal(it, e)) && Objects.equal(it.getName(), e.getName())));
    })))) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Model elements should not have duplicated names.");
      this.error(_builder.toString(), e, OntoUMLArchivePackage.eINSTANCE.getModelElement_Name(), 
        OntoUMLArchiveValidator.DUPLICATED_NAME);
    }
  }
  
  @Check
  public void checkGeneralizationEnds(final Generalization g) {
    it.unibz.inf.ontouml.archive.ontoUMLArchive.Class _super = g.getSuper();
    it.unibz.inf.ontouml.archive.ontoUMLArchive.Class _sub = g.getSub();
    boolean _equals = Objects.equal(_super, _sub);
    if (_equals) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Generalizations are not reflexive.");
      this.error(_builder.toString(), g, 
        OntoUMLArchivePackage.eINSTANCE.getGeneralization_Super(), 
        OntoUMLArchiveValidator.REFLEXIVE_GENERALIZATION);
    }
  }
  
  @Check
  public void checkUnexpectedClassStereotypes(final it.unibz.inf.ontouml.archive.ontoUMLArchive.Class c) {
    EList<String> _stereotypes = c.getStereotypes();
    for (final String str : _stereotypes) {
      boolean _contains = OntoUMLArchiveUtils.getExpectedClassStereotypes().contains(str);
      boolean _not = (!_contains);
      if (_not) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Unexpected class stereotype");
        this.warning(_builder.toString(), c, 
          OntoUMLArchivePackage.eINSTANCE.getClass_Stereotypes(), 
          c.getStereotypes().indexOf(str), OntoUMLArchiveValidator.UNEXPECTED_STEREOTYPE);
      }
    }
  }
  
  @Check
  public void checkUnexpectedBinaryAssociationStereotypes(final BinaryAssociation a) {
    EList<String> _stereotypes = a.getStereotypes();
    for (final String str : _stereotypes) {
      boolean _contains = OntoUMLArchiveUtils.getExpectedBinaryAssociationStereotypes().contains(str);
      boolean _not = (!_contains);
      if (_not) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Unexpected class stereotype");
        this.warning(_builder.toString(), a, 
          OntoUMLArchivePackage.eINSTANCE.getAssociation_Stereotypes(), 
          a.getStereotypes().indexOf(str), OntoUMLArchiveValidator.UNEXPECTED_STEREOTYPE);
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkDuplicatedGeneralizations(final Generalization g) {
    final Function1<ModelElement, Boolean> _function = (ModelElement it) -> {
      boolean _xifexpression = false;
      if (((it != g) && (it instanceof Generalization))) {
        _xifexpression = (Objects.equal(((Generalization) it).getSuper(), g.getSuper()) && Objects.equal(((Generalization) it).getSub(), g.getSub()));
      } else {
        _xifexpression = false;
      }
      return Boolean.valueOf(_xifexpression);
    };
    final ModelElement g2 = IterableExtensions.<ModelElement>findFirst(this._ontoUMLArchiveUtils.getModelElements(this._ontoUMLArchiveUtils.getContainerModel(g)), _function);
    if ((g2 != null)) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Duplicated generalization.");
      this.warning(_builder.toString(), g, 
        OntoUMLArchivePackage.eINSTANCE.getModelElement_Name(), 
        OntoUMLArchiveValidator.DUPLICATED_GENERALIZATION);
    }
  }
}
